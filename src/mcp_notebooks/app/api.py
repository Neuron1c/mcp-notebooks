import asyncio
import logging
from contextlib import asynccontextmanager
from collections.abc import AsyncIterator
from mcp.server.fastmcp import FastMCP
from mcp_notebooks.models.schema import (
    StartKernelResponse,
    CodeSnippet,
    ExecuteResponse,
    ShutdownResponse,
    GetNotebookResponse,
)
from mcp_notebooks.core.manager import SessionManager, SessionNotFoundError

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
session_manager = SessionManager()


@asynccontextmanager
async def app_lifespan(server: FastMCP) -> AsyncIterator[str]:
    """Manage application lifecycle with type-safe context"""
    # Initialize on startup
    task = None
    try:
        task = asyncio.create_task(session_manager.cleanup())
        yield ""
    finally:
        logger.info("Cleaning up sessions...")
        if task is not None:
            task.cancel()

        await session_manager.cleanup(force=True)


mcp = FastMCP(
    "mcp_notebooks", dependencies=["jupyterlab", "fastapi"], lifespan=app_lifespan
)


@mcp.tool("start", description="Start a new Jupyter kernel session")
async def start_kernel() -> StartKernelResponse:
    """
    Start a new Jupyter kernel session.

    Returns:
        A unique session ID and a message indicating the session was successfully created.
    """

    session_id = session_manager.create_session()
    return StartKernelResponse(session_id=session_id, message="success")


@mcp.tool("execute", description="Execute code in a Jupyter kernel session")
async def execute_code(snippet: CodeSnippet) -> ExecuteResponse:
    """
    Execute a code snippet in the specified kernel session.

    Args:
        snippet: A CodeSnippet object containing the session ID and code to run.

    Returns:
        Outputs generated by the code execution and the execution count.
    """

    session = session_manager.get_session(snippet.session_id)
    response = session.execute(snippet.code)

    return ExecuteResponse(
        outputs=response.outputs, execution_count=response.execution_count
    )


@mcp.tool(
    "get_notebook",
    description="Get notebook contents from a Jupyter kernel session",
)
async def get_notebook(session_id: str) -> GetNotebookResponse:
    """
    Shut down an active kernel session and return its notebook contents.

    Args:
        session_id: The ID of the kernel session get the notebook from.

    Returns:
        A dictionary containing the notebook contents accumulated during the session.
    """

    session = session_manager.get_session(session_id)
    notebook = session.get_notebook()

    return GetNotebookResponse(notebook=notebook)


@mcp.tool("shutdown", description="Shut down a Jupyter kernel session")
async def shutdown_kernel(session_id: str) -> ShutdownResponse:
    """
    Shut down an active kernel session and return its notebook contents.

    Args:
        session_id: The ID of the kernel session to shut down.

    Returns:
        A dictionary containing the notebook contents accumulated during the session.
    """

    output = session_manager.delete_session(session_id)
    return ShutdownResponse(
        message="success",
        notebook=output,
    )


@mcp.resource(
    "notebook-running://{session_id}",
    description="Check if a Jupyter kernel session is running",
)
async def notebook_running(session_id: str) -> bool:
    """
    Show whether a notebook session is still running.

    Args:
        session_id: The ID of the kernel session get the notebook from.

    Returns:
        A dictionary containing the notebook contents accumulated during the session.
    """
    try:
        session_manager.get_session(session_id)
        return True
    except SessionNotFoundError:
        return False
